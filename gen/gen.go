// Package main generates simple osa wrapper implementations.
// Warning: Here be dragons.
package main

import (
	"bytes"
	"flag"
	"fmt"
	"go/ast"
	"go/format"
	"go/parser"
	"go/token"
	"os"
	"path/filepath"
	"regexp"
	"sort"
	"strings"
	"text/template"

	"github.com/MakeNowJust/heredoc/v2"
	"github.com/scylladb/go-set/strset"
)

const (
	osaPkg    string = "osa"
	osaI      string = "I"
	outPrefix string = "gen_"
)

var (
	pkgPath   string
	osaName   string
	osaParent string
	importPkg string
	outDir    string
)

func main() {
	flag.StringVar(&pkgPath, "pkg", ".", "path to the osa package")
	flag.StringVar(&osaName, "name", "", "name of the struct")
	flag.StringVar(&osaParent, "call", "", "name of the parent")
	flag.StringVar(&importPkg, "import", "", "import packages")
	flag.StringVar(&outDir, "out", ".", "path to the output dir")

	flag.Parse()

	if pkgPath == "" {
		panic("package path missing")
	}
	cwd, err := os.Getwd()
	requireNoErr(err)
	currFile := os.Getenv("GOFILE")
	currFilePath := filepath.Join(cwd, currFile)
	currPkg := os.Getenv("GOPACKAGE")

	osaP := newOsaParser(currFilePath, currPkg)

	methods := osaP.methods(osaI)

	imports := collectImports(methods)
	if importPkg != "" {
		imports.Add(importPkg)
	}

	outTpl := heredoc.Doc(`
		package {{.Pkg}}

		{{if .Imports}}
		import ({{range .Imports}}
			"{{.}}"{{end}}
		)
		{{end}}

		{{if .Osa}}
		type {{.Osa}} struct{}
		{{end}}

		{{range .Funcs}}
		{{.Doc}}func {{if $.Osa}}({{$.Osa}}) {{end}}{{.Sig}} {
			{{if .Returns}}return {{end}}{{.Cmd}}
		}{{end}}
	`)
	tpl := template.Must(template.New("out").Parse(outTpl))
	tplVars := struct {
		Pkg     string
		Imports []string
		Osa     string
		Funcs   []methodTplVars
	}{
		Pkg:     currPkg,
		Imports: fmtImports(imports),
		Osa:     osaName,
		Funcs:   osaP.fmtMethods(methods),
	}

	var outBuff bytes.Buffer
	fmt.Fprintf(&outBuff, "// Code generated by osa/gen. DO NOT EDIT.\n")
	err = tpl.Execute(&outBuff, tplVars)
	requireNoErr(err)

	out := outBuff.Bytes()
	out, err = format.Source(out)
	requireNoErr(err)

	outPath := filepath.Join(outDir, outPrefix+currFile)
	err = os.WriteFile(outPath, out, 0666)
	requireNoErr(err)
}

type methodTplVars struct {
	Doc     string
	Name    string
	Sig     string
	Cmd     string
	Returns bool
}

type method struct {
	m      *ast.Field
	ft     *ast.FuncType
	file   *osaFile
	name   string
	parent string
	isVar  bool
}

type osaFile struct {
	pkg  string
	path string
	ast  *ast.File
	src  []byte
}

type osaParser struct {
	fset    *token.FileSet
	files   []osaFile
	currPkg string
}

func newOsaParser(
	currFilePath string,
	currPkg string,
) osaParser {
	filePaths := []string{currFilePath}
	seenFiles := strset.NewWithSize(1)
	seenFiles.Add(currFilePath)

	pkgPath, err := filepath.Abs(pkgPath)
	requireNoErr(err)
	entries, err := os.ReadDir(pkgPath)
	requireNoErr(err)

	fset := token.NewFileSet()
	files := make([]osaFile, 0)
	for _, e := range entries {
		name := e.Name()
		if e.IsDir() || !strings.HasSuffix(name, ".go") {
			continue
		}
		if strings.HasPrefix(name, outPrefix) {
			continue
		}
		if strings.HasSuffix(name, "_test.go") {
			continue
		}
		path := filepath.Join(pkgPath, name)
		if seenFiles.Has(path) {
			continue
		}
		seenFiles.Add(path)
		filePaths = append(filePaths, path)
	}

	for _, fp := range filePaths {
		src, err := os.ReadFile(fp)
		requireNoErr(err)

		if wasGenerated(src) {
			continue
		}

		f, err := parser.ParseFile(fset, fp, src, parser.ParseComments)
		requireNoErr(err)
		pkg := f.Name.Name
		if pkg != osaPkg && pkg != currPkg {
			continue
		}
		files = append(files, osaFile{
			pkg:  pkg,
			path: fp,
			ast:  f,
			src:  src,
		})
	}

	if len(files) == 0 {
		panic("osa package not found")
	}

	return osaParser{
		fset:    fset,
		files:   files,
		currPkg: currPkg,
	}
}

func (p osaParser) findObj(name string) (
	obj *ast.Object,
	file osaFile,
) {
	for _, file = range p.files {
		if obj = file.ast.Scope.Lookup(name); obj != nil {
			return
		}
	}
	return nil, osaFile{}
}

func (p osaParser) methods(iName string) []method {
	iObj, file := p.findObj(iName)

	iT := iObj.Decl.(*ast.TypeSpec).Type.(*ast.InterfaceType)
	iMs := iT.Methods.List
	methods := make([]method, 0, len(iMs))
	for _, m := range iMs {
		switch t := m.Type.(type) {
		case *ast.FuncType:
			name := m.Names[0].String()
			parent, localPkg, isVar := p.scanMethodName(name)
			if osaName == "" && localPkg == p.currPkg {
				continue
			}
			m := method{m, t, &file, name, parent, isVar}
			methods = append(methods, m)
		case *ast.Ident:
			subI := t.Name
			methods = append(methods, p.methods(subI)...)
		default:
			panic("unexpected ast.Expr type")
		}
	}
	return methods
}

func (p osaParser) scanMethodName(name string) (
	parent string,
	localPkg string,
	isVar bool,
) {
	parent = osaParent
	for _, file := range p.files {
		if obj := file.ast.Scope.Lookup(name); obj != nil {
			localPkg = file.pkg
			if localPkg != osaPkg {
				parent = localPkg
			}
			if localPkg == p.currPkg {
				parent = ""
			}
			isVar = obj.Kind == ast.Var
			return
		}
	}
	return
}

func (p osaParser) fmtMethods(methods []method) []methodTplVars {
	ms := make([]methodTplVars, len(methods))
	for i, m := range methods {
		cmd := fmtFuncArgs(m.ft)
		if !m.isVar {
			cmd = "(" + cmd + ")"
		}
		cmd = m.name + cmd
		if m.parent != "" {
			cmd = m.parent + "." + cmd
		}
		ms[i] = methodTplVars{
			Doc:     fmtDoc(m.m),
			Name:    m.name,
			Sig:     string(p.extractSrcSlice(m.file.src, m.m)),
			Cmd:     cmd,
			Returns: m.ft.Results != nil,
		}
	}
	return ms
}

func (p osaParser) extractSrcSlice(src []byte, field *ast.Field) []byte {
	from := p.fset.Position(field.Pos()).Offset
	to := p.fset.Position(field.End()).Offset
	return src[from:to]
}

func requireNoErr(err error) {
	if err != nil {
		panic(err)
	}
}

func wasGenerated(src []byte) bool {
	re := regexp.MustCompile(`(?m)^// Code generated .* DO NOT EDIT\.$`)
	return re.Match(src)
}

func collectImports(methods []method) *strset.Set {
	imports := strset.New()
	for _, method := range methods {
		res := method.ft.Results
		if res == nil {
			continue
		}
		for _, rf := range method.ft.Results.List {
			rt := rf.Type
			if rse, ok := rt.(*ast.SelectorExpr); ok {
				pkg := rse.X.(*ast.Ident).Name
				imports.Add(pkg)
			}
		}
	}
	return imports
}

func fmtImports(imports *strset.Set) []string {
	l := imports.List()
	sort.Strings(l)
	return l
}

func fmtDoc(field *ast.Field) string {
	doc := ""
	if field.Doc != nil {
		for _, d := range field.Doc.List {
			doc += d.Text + "\n"
		}
	}
	return doc
}

func fmtFuncArgs(f *ast.FuncType) string {
	args := make([]string, 0, len(f.Params.List))
	for _, fld := range f.Params.List {
		for _, name := range fld.Names {
			args = append(args, name.Name)
		}
	}
	return strings.Join(args, ", ")
}
